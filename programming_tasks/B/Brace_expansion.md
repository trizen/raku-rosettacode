[1]: https://rosettacode.org/wiki/Brace_expansion

# [Brace expansion][1]


The task description allows the taking of shortcuts, but please note that we are not taking any shortcuts here.  The solution is short because this particular problem happens to map quite naturally to the strengths of Raku.



First, the parsing is handled with a grammar that can backtrack in the few places this problem needs it.  The `+` quantifier matches one or more alternatives (we handle the case of a single alternative in the walk now), and the `%` modifier requires a comma between each quantified item to its left.  Note that the `*` quantifiers do *not* backtrack here, because the `token` keyword suppresses that; all the backtracking here fails over to a different alternative in an outer alternation (that is, things separated by the `|` character in the grammar. Most of these failovers just nibble an uninteresting character and continue.)



On the other end, we recursively walk the parse tree returning expanded sublists, and we do the cartesian concatenation of sublists at each level by use of the `X~` operator, which is a "cross" metaoperator used on a simple `~` concatenation.  As a list infix operator, `X~` does not care how many items are on either side, which is just what you want in this case, since some of the arguments are strings and some are lists.  Here we use a fold or reduction form in square brackets to interpose the cross-concat between each value generated by the map, which returns a mixture of lists and literal strings.  One other thing that might not be obvious: if we bind to the match variable, `$/`, we automatically get all the syntactic sugar for its submatches.  In this case, `$0` is short for `$/[0]`, and represents all the submatches captured by 0th set of parens in either `TOP` or `alt`.  `$<meta>` is likewise short for `$/<meta>`, and retrieves what was captured by that named submatch.

```perl
grammar BraceExpansion {
    token TOP  { ( <meta> | . )* }
    token meta { '{' <alts> '}' | \\ .  }
    token alts { <alt>+ % ',' }
    token alt  { ( <meta> | <-[ , } ]> )* }
}

sub crosswalk($/) {
    |[X~] flat '', $0.map: -> $/ { $<meta><alts><alt>.&alternatives or ~$/ }
}

sub alternatives($_) {
    when :not { () }
    when 1    { '{' X~ $_».&crosswalk X~ '}' }
    default   { $_».&crosswalk }
}

sub brace-expand($s) { crosswalk BraceExpansion.parse($s) }

# Testing:

sub bxtest(*@s) {
    for @s -> $s {
        say "\n$s";
        for brace-expand($s) {
            say "    ", $_;
        }
    }
}

bxtest Q:to/END/.lines;
    ~/{Downloads,Pictures}/*.{jpg,gif,png}
    It{{em,alic}iz,erat}e{d,}, please.
    {,{,gotta have{ ,\, again\, }}more }cowbell!
    a{b{1,2}c
    a{1,2}b}c
    a{1,{2},3}b
    more{ darn{ cowbell,},}
    ab{c,d\,e{f,g\h},i\,j{k,l\,m}n,o\,p}qr
    {a,{\,b}c
    a{b,{{c}}
    {a{\}b,c}d
    END
```

#### Output:
```
~/{Downloads,Pictures}/*.{jpg,gif,png}
    ~/Downloads/*.jpg
    ~/Downloads/*.gif
    ~/Downloads/*.png
    ~/Pictures/*.jpg
    ~/Pictures/*.gif
    ~/Pictures/*.png

It{{em,alic}iz,erat}e{d,}, please.
    Itemized, please.
    Itemize, please.
    Italicized, please.
    Italicize, please.
    Iterated, please.
    Iterate, please.

{,{,gotta have{ ,\, again\, }}more }cowbell!
    cowbell!
    more cowbell!
    gotta have more cowbell!
    gotta have\, again\, more cowbell!

{}} some {\\{edge,edgy} }{ cases, here\\\}
    {}} some {\\edge }{ cases, here\\\}
    {}} some {\\edgy }{ cases, here\\\}

a{b{1,2}c
    a{b1c
    a{b2c

a{1,2}b}c
    a1b}c
    a2b}c

a{1,{2},3}b
    a1b
    a{2}b
    a3b

more{ darn{ cowbell,},}
    more darn cowbell
    more darn
    more

ab{c,d\,e{f,g\h},i\,j{k,l\,m}n,o\,p}qr
    abcqr
    abd\,efqr
    abd\,eg\hqr
    abi\,jknqr
    abi\,jl\,mnqr
    abo\,pqr

{a,{\,b}c
    {a,{\,b}c

a{b,{{c}}
    a{b,{{c}}

{a{\}b,c}d
    {a\}bd
    {acd
```
